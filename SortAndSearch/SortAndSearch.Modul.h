//Сапожников Юрий ИВТ-22
#pragma once

using namespace std;

/// Функция заполняет массив случайными числами в диапазоне [MIN, MAX]
/// a - ссылка на массив, который нужно заполнить
/// MAX - верхняя граница случайных чисел
/// MIN - нижняя граница случайных чисел
void random_array(vector<int>& a, size_t MAX, size_t MIN) {
	for (int i = 0; i < a.size(); i++) {
		a[i] = rand() % MAX + MIN;  // Случайное значение массива от MIN до MAX
	}
}

/// Функция выводит элементы массива на экран через пробел
/// a - ссылка на массив, элементы которого нужно вывести
void print_array_vector(const vector<int>& a) {
	for (size_t i = 0; i < a.size(); i++) {
		cout << a[i] << " ";
	}
	cout << endl;
}

/// Функция сортирует массив методом пузырьковой сортировки по возрастанию
/// T - шаблонный тип данных в массиве
/// arr - ссылка на массив для сортировки
/// 
/// Алгоритм выполняет попарное сравнение соседних элементов и перемещает большие значения вправо
/// BigO = O(n^2) в худшем и среднем случаях, O(n) в лучшем случае
template <typename T>
void bubblesort(vector<T>& arr) {
	if (0 >= arr.size()) return;
	for (size_t i = 0; i < arr.size() - 1; i++) {
		for (size_t j = 0; j < arr.size() - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				swap(arr[j], arr[j + 1]);
			}
		}
	}
}

/// Функция сортирует массив методом Шелла по возрастанию
/// T - шаблонный тип данных в массиве
/// arr - ссылка на массив для сортировки
/// 
/// Алгоритм использует уменьшение разрыва (gap) между элементами для сравнения.
/// BigO = O(n^2) в худшем случае, O(n log^2(n)) в среднем, O(n log(n)) в лучшем.
template <typename T>
void shellsort(vector<T>& arr) {
	for (size_t gap = arr.size() / 2; gap > 0; gap /= 2) {
		for (size_t i = gap; i < arr.size(); i++) {
			T temp = arr[i];
			size_t j;
			for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
				arr[j] = arr[j - gap];
			}
			arr[j] = temp;
		}
	}
}

/// Функция сортирует массив методом быстрой сортировки по возрастанию
/// T - шаблонный тип данных в массиве
/// arr - ссылка на массив для сортировки
/// begin - начальный индекс диапазона сортировки
/// end - конечный индекс диапазона сортировки
/// 
/// Алгоритм использует опорный элемент для разделения массива на две части и сортирует их рекурсивно.
/// BigO = O(n log(n)) в среднем, O(n^2) в худшем случае (при неудачном выборе опорного элемента).
template <typename T>
void quicksort(vector<T>& arr, size_t begin, size_t end) {
	if (begin >= end) return;

	size_t base = begin; //опорный элемент
	size_t current = begin;//элемент который перемещается влево от опорного

	for (size_t i = begin + 1; i <= end; i++) {
		if (arr[i] < arr[base]) {				//если элемент arr[i] меньше опорного
			swap(arr[i], arr[current + 1]); //меняем его и опорный элемент местами
			current++;  
		}
	}
	swap(arr[base], arr[current]);     //опорный элемент ставится на место последнего перемещеного

	if (current > begin) {
		quicksort(arr, begin, current - 1);//вызов функции для левой части массива
	}
	if (end > current + 1) {
		quicksort(arr, current + 1, end);//вызов функции для правой части массива
	}
}
/// Функция сливает два отсортированных подмассива в один отсортированный массив
/// T - шаблонный тип данных в массиве
/// a - ссылка на массив, содержащий две области для слияния
/// begin - начальный индекс первой области
/// mid - индекс, разделяющий области
/// end - конечный индекс второй области
/// 
/// Используется в сортировке слиянием. 
/// Временная сложность = O(n), где n - число элементов в объединяемых областях.
template<typename T>
void merging(vector<T>& a, size_t begin, size_t mid, size_t end) {
	T* c = new T[end - begin];					//буфер для хранения результата слияния

	size_t
		left = begin,						//индекс элемента из левой области
		right = mid,							//индекс элемента из правой области
		i = 0;								//индекс массива c 

	while (left < mid && right < end) {			//пока не достигнут конец одной из областей
		if (a[left] <= a[right]) {				//сравниваются значения из областей

			c[i] = a[left];						// если left меньше right, то в индекс i массива с помещаем значение из левой области
			left++;
		}
		else {
			c[i] = a[right];					//в противном случае из правой
			right++;
		}
		i++;
	}
	//помещаем оставшиеся значения в массив c
	if (left == mid) {							//если был достигнут конец левой части

		while (right < end) {					//то помещаем значения из правой

			c[i] = a[right];
			right++;
			i++;
		}
	}
	else if (right == end) {					//если же был достигнут конец правой части

		while (left < mid) {				// то помеащем знаяения из левой

			c[i] = a[left];
			left++;
			i++;
		}
	}

	size_t j = 0;
	while (j < end - begin) {					//помещение значений из массива с в массив а
		a[begin + j] = c[j];
		j++;
	}
	delete[] c;
}

/// Рекурсивная функция сортировки слиянием по возрастанию
/// T - тип данных в массиве
/// a - ссылка на массив для сортировки
/// left - левая граница сортируемой области
/// right - правая граница сортируемой области
/// 
/// Делит массив на две части, рекурсивно сортирует их и объединяет.
/// BigO = O(n log(n)) для всех случаев.
template<typename T>
void mergesort(vector<T>& a, size_t left, size_t right) {

	if (left < right - 1) {
		size_t mid = left + (right - left) / 2;
		mergesort(a, left, mid);	//сортировка левой половины сортируемой области
		mergesort(a, mid, right);  //сортировка правйо половины сортируемой области
		merging(a, left, mid, right);
	}
}

/// Функция выполняет бинарный поиск элемента в массиве
/// T - тип данных в массиве
/// arr - ссылка на массив, в котором выполняется поиск
/// begin - начальный индекс диапазона поиска
/// end - конечный индекс диапазона поиска
/// value - искомое значение
/// Индекс элемента, если найден, или -1, если не найден
/// 
/// Алгоритм работает только с отсортированными массивами.
/// BigO = O(log(n)).
template <typename T>
int binsearch(vector<T>& arr, size_t begin, size_t end, T value) {
	size_t left = begin;
	size_t right = end - 1;

	while (left <= right) {
		size_t mid = left + (right - left) / 2; // Находим середину

		if (arr[mid] == value) { // Если найден
			return value; // Возвращаем индекс
		}
		else if (arr[mid] < value) { // Если значение больше, ищем справа
			left = mid + 1;
		}
		else { // Если значение меньше, ищем слева
			right = mid - 1;
		}
	}
	return -1; // Если не найден
}

/// Функция выполняет интерполяционный поиск элемента в массиве
/// T - тип данных в массиве
/// arr - ссылка на массив, в котором выполняется поиск
/// begin - начальный индекс диапазона поиска
/// end - конечный индекс диапазона поиска
/// value - искомое значение
/// Индекс элемента, если найден, или -1, если не найден
/// 
/// Алгоритм работает только с отсортированными массивами и эффективен при равномерном распределении данных.
/// BigO = O(log(log(n))) в среднем, O(n) в худшем случае.
template <typename T>
int interpolationsearch(vector<T>& arr, size_t begin, size_t end, T value) {
	size_t left = begin;
	size_t right = end - 1;

	while (left <= right && value >= arr[left] && value <= arr[right]) {
		// Находим позицию, используя интерполяцию
		size_t pos = left + ((value - arr[left]) * (right - left) / (arr[right] - arr[left]));

		if (arr[pos] == value) { // Если найден
			return value; // Возвращаем индекс
		}
		else if (arr[pos] < value) { // Если значение больше, ищем справа
			left = pos + 1;
		}
		else { // Если значение меньше, ищем слева
			right = pos - 1;
		}
	}
	return -1; // Если не найден
}

/// Функция проверяет, отсортирован ли массив по возрастанию
/// T - тип данных в массиве
/// arr - ссылка на массив для проверки
/// true, если массив отсортирован, иначе false
/// 
/// BigO = O(n).
template <typename T>
bool sort_check(const vector<T>& arr) {
		for (size_t i = 0; i < arr.size() - 1; i++) {
			if (arr[i] > arr[i + 1]) {
				return false;
			}
		};
		return true;
}	